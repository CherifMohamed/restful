<?php

/**
 * @file
 * Contains RestfulDiscoveryTestCase
 */

use Drupal\restful\Http\Request;
use Drupal\restful\Http\RequestInterface;

class RestfulDiscoveryTestCase extends RestfulCurlBaseTestCase {

  /**
   * {@inheritdoc}
   */
  public static function getInfo() {
    return array(
      'name' => 'Discovery',
      'description' => 'Test the discovery features.',
      'group' => 'RESTful',
    );
  }

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    parent::setUp('restful_test');
    // Add common fields, vocabulary and terms.
    restful_test_add_fields();
  }

  /**
   * Test the headers populated in an OPTIONS request.
   */
  public function testOptionsMethod() {
    // 1. Assert Access-Control-Allow-Methods.
    $response = $this->httpRequest('api/v1.4/test_articles', RequestInterface::METHOD_OPTIONS);
    $this->assertTrue(strpos($response['headers'], sprintf('access-control-allow-methods: %s', implode(', ', array(
        RequestInterface::METHOD_HEAD,
        RequestInterface::METHOD_OPTIONS,
      )))) !== FALSE, 'Access-Control-Allow-Methods header is populated correctly.');
    // Make sure it returns the appropriate headers for every path.
    $response = $this->httpRequest('api/v1.4/test_articles/1', RequestInterface::METHOD_OPTIONS);
    $this->assertTrue(strpos($response['headers'], sprintf('access-control-allow-methods: %s', implode(', ', array(
        RequestInterface::METHOD_PATCH,
        RequestInterface::METHOD_DELETE,
        RequestInterface::METHOD_OPTIONS,
      )))) !== FALSE, 'Access-Control-Allow-Methods header is populated correctly for different paths.');

    // 2. Assert Accept.
    // List the content types the route accepts.
    $this->assertTrue(strpos($response['headers'], 'accept: application/xml; charset=utf-8') !== FALSE, 'Accept header is populated correctly for configured formatter.');
    $response = $this->httpRequest('api/v1.2/test_articles', RequestInterface::METHOD_OPTIONS);
    $this->assertTrue(strpos($response['headers'], 'application/hal+json, application/json, application/vnd.api+json, application/drupal.single+json, application/xml; charset=utf-8') !== FALSE, 'Accept header is populated correctly for non configured formatters.');

    // 3. Assert Access-Control-Allow-Origin.
    $response = $this->httpRequest('api/v1.4/test_articles', RequestInterface::METHOD_HEAD);
    $this->assertTrue(strpos($response['headers'], 'access-control-allow-origin: *') !== FALSE, 'Accept header is populated correctly for non configured formatters.');

    // 4. Assert Access.
    $response = $this->httpRequest('api/v1.4/test_articles/1', RequestInterface::METHOD_HEAD);
    $this->assertTrue($response['code'], 400, 'Access is denied for unsupported HTTP methods.');
  }

  /**
   * Field discovery.
   */
  public function testFieldDiscovery() {
    // Create an entity.
    $entity = entity_create('entity_test', array('name' => 'main', 'label' => $this->randomName()));
    $pid = $entity->save();
    $handler = restful()->getResourceManager()->getPlugin('main:1.1');
    $handler->setRequest(Request::create('api/v1.1/main/' . $pid, array(), RequestInterface::METHOD_OPTIONS));
    $handler->setPath($pid);
    $formatter = restful()
      ->getFormatterManager()
      ->negotiateFormatter(NULL);
    $formatter->setResource($handler);
    $result = $formatter->prepare($handler->process());
    $expected = array(
      'id' => array(
        'data' => array(
          'cardinality' => 1,
          'read_only' => TRUE,
          'type' => 'integer',
          'required' => TRUE,
        ),
        'info' => array(
          'description' => t('Base ID for the entity.'),
          'label' => t('ID'),
        ),
      ),
      'label' => array(
        'data' => array(
          'cardinality' => 1,
          'read_only' => FALSE,
          'type' => 'string',
          'required' => FALSE,
          'size' => 255,
        ),
        'form_element' => array(
          'allowed_values' => NULL,
          'type' => 'texfield',
          'default_value' => '',
          'placeholder' => '',
          'size' => 255,
          'description' => 'The label of the resource.',
          'title' => 'label',
        ),
        'info' => array(
          'description' => t('The label of the resource.'),
          'label' => t('Label'),
        ),
      ),
      'text_multiple' => array(
        'data' => array(
          'cardinality' => FIELD_CARDINALITY_UNLIMITED,
          'read_only' => FALSE,
          'type' => 'string',
          'size' => 255,
          'required' => FALSE,
        ),
        'form_element' => array(
          'allowed_values' => NULL,
          'default_value' => '',
          'placeholder' => t('This is helpful.'),
          'size' => 255,
          'type' => 'textfield',
          'description' => 'This field holds different text inputs.',
          'title' => 'text_multiple',
        ),
        'info' => array(
          'description' => t('This field holds different text inputs.'),
          'label' => t('Text multiple'),
        ),
      ),
    );

    foreach ($expected as $public_field => $discovery_info) {
      $result_data = $result[$public_field]['data'];
      $expected_data = $expected[$public_field]['data'];
      ksort($result_data);
      ksort($expected_data);
      $this->assertEqual($result_data, $expected_data, format_string('The "data" information is properly described for @field.', array('@field' => $public_field)));
      $result_form_element = $result[$public_field]['form_element'];
      $expected_form_element = $expected[$public_field]['form_element'];
      ksort($result_form_element);
      ksort($expected_form_element);
      $this->assertEqual($result_form_element, $expected_form_element, format_string('The "form_element" information is properly described for @field.', array('@field' => $public_field)));
      $result_info = $result[$public_field]['info'];
      $expected_info = $expected[$public_field]['info'];
      ksort($result_info);
      ksort($expected_info);
      $this->assertEqual($result_info, $expected_info, format_string('The "info" information is properly described for @field.', array('@field' => $public_field)));
    }
  }

  /**
   * Field discovery allowed values.
   */
  public function testFieldDiscoveryAllowedValues() {
    $handler = restful_get_restful_handler('test_articles', 1, 2);

    // Add entity reference fields.
    restful_test_add_fields('node', 'article');

    // Create 3 nodes.
    $expected_result = array();
    foreach (array(1, 2, 3) as $id) {
      $title = 'article' . '/' . $id;
      $settings = array(
        'title' => $title,
        'type' => 'article',

      );
      $node = $this->drupalCreateNode($settings);
      $expected_result[$node->nid] = $title;
    }

    // Set widget to select list.
    $instance = field_info_instance('node', 'entity_reference_single', 'article');
    $instance['widget']['type'] = 'options_select';
    field_update_instance($instance);

    $result = $handler->options();
    $this->assertEqual($result['entity_reference_single']['form_element']['allowed_values'], $expected_result);

    // Set widget to autocomplete.
    $instance['widget']['type'] = 'entityreference_autocomplete';
    field_update_instance($instance);

    // Invalidate public fields cache.
    $handler->setPublicFields(array());

    $result = $handler->options();
    $this->assertNull($result['entity_reference_single']['form_element']['allowed_values']);
  }

}
